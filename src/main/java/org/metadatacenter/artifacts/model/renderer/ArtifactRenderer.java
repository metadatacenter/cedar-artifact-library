package org.metadatacenter.artifacts.model.renderer;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
import org.metadatacenter.artifacts.model.core.Artifact;
import org.metadatacenter.artifacts.model.core.ElementSchemaArtifact;
import org.metadatacenter.artifacts.model.core.FieldSchemaArtifact;
import org.metadatacenter.artifacts.model.core.MonitoredArtifact;
import org.metadatacenter.artifacts.model.core.ParentSchemaArtifact;
import org.metadatacenter.artifacts.model.core.SchemaArtifact;
import org.metadatacenter.artifacts.model.core.TemplateSchemaArtifact;
import org.metadatacenter.model.ModelNodeNames;

import java.net.URI;
import java.util.Map;

public class ArtifactRenderer
{
  private final ObjectMapper mapper;

  public ArtifactRenderer()
  {
    this.mapper = new ObjectMapper();
    mapper.registerModule(new Jdk8Module());
    mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);
  }

  /**
   * Generate a specification for a template schema artifact
   * <p></p>
   * An example artifact specification could look as follows:
   * <pre>
   * {
   *   "$schema": "http://json-schema.org/draft-04/schema#",
   *   "type": "object",
   *   "title": "Study template schema", "description": "Study template schema generated by the CEDAR Template Editor 2.6.19",
   *   "schema:name": "Study", "schema:description": "Study template",
   *   "schema:schemaVersion": "1.6.0", "schema:identifier": "id1212132",
   *   "pav:version": "0.0.1", "bibo:status": "bibo:draft",
   *   "pav:previousVersion": "https://repo.metadatacenter.org/templates/54343",
   *   "pav:derivedFrom": "https://repo.metadatacenter.org/templats/232323",
   *   "@type": "https://schema.metadatacenter.org/core/Template",
   *   "@id": "https://repo.metadatacenter.org/templates/474378",
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332",
   *   "@context": { ... },
   *   "properties": { ... },
   *   "required": [ "xsd", "pav", "schema", "oslc", "bibo",
   *                 "schema:isBasedOn", "schema:name", "schema:description",
   *                 "pav:createdOn", "pav:createdBy", "pav:lastUpdatedOn", "oslc:modifiedBy",
   *                 "Child Name 1", ... "Child Name n"],
   *   "additionalProperties": false,
   *   "_ui": { ... }
   *  }
   * </pre>
   */
  public ObjectNode renderTemplateSchemaArtifact(TemplateSchemaArtifact templateSchemaArtifact)
  {
    ObjectNode rendering = renderSchemaArtifact(templateSchemaArtifact);

    rendering.set(ModelNodeNames.JSON_LD_CONTEXT, renderParentSchemaArtifactContextJsonLdSpecification());

    rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES,
      renderParentSchemaArtifactPropertiesJsonSchemaSpecification(templateSchemaArtifact));

    rendering.put(ModelNodeNames.JSON_SCHEMA_REQUIRED, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.XSD);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.BIBO);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.OSLC);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_CONTEXT);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_ID);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA_IS_BASED_ON);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA_ORG_NAME);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA_ORG_DESCRIPTION);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_CREATED_ON);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_CREATED_BY);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_LAST_UPDATED_ON);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.OSLC_MODIFIED_BY);

    for (String childName : templateSchemaArtifact.getChildNames())
      rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(childName);

    if (templateSchemaArtifact.hasAttributeValueField())
      rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES,
        renderAdditionalPropertiesForAttributeValueFieldJsonSchemaSpecification());
    else
      rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES, false);

    rendering.put(ModelNodeNames.UI, mapper.valueToTree(templateSchemaArtifact.getTemplateUI()));

    return rendering;
  }

  /**
   * Generate a specification for an element schema artifact
   * <p></p>
   * An example artifact specification could look as follows:
   * <pre>
   * {
   *   "$schema": "http://json-schema.org/draft-04/schema#",
   *   "type": "object",
   *   "title": "Address element schema", "description: "Address element schema generated by the CEDAR Template Editor 2.6.19",
   *   "schema:name": "Address", "schema:description": "Address element",
   *   "schema:schemaVersion": "1.6.0", "schema:identifier": "id999434",
   *   "pav:version": "0.0.1", "bibo:status": "bibo:draft",
   *   "pav:previousVersion": "https://repo.metadatacenter.org/template-elements/54343",
   *   "pav:derivedFrom": "https://repo.metadatacenter.org/template-elements/232323",
   *   "@type": "https://schema.metadatacenter.org/core/TemplateElement",
   *   "@id": "https://repo.metadatacenter.org/templates-elements/474378",
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332",
   *   "@context": { ... },
   *   "properties": { ... },
   *   "required": [ "xsd", "pav", "schema", "oslc", "bibo",
   *                 "schema:isBasedOn", "schema:name", "schema:description",
   *                 "pav:createdOn", "pav:createdBy", "pav:lastUpdatedOn", "oslc:modifiedBy",
   *                 "Child Name 1", ... "Child Name n"],
   *   "additionalProperties": false,
   *   "_ui": { ... }
   *  }
   * </pre>
   */
  public ObjectNode renderElementSchemaArtifact(ElementSchemaArtifact elementSchemaArtifact)
  {
    ObjectNode rendering = renderSchemaArtifact(elementSchemaArtifact);

    rendering.put(ModelNodeNames.JSON_LD_CONTEXT, renderParentSchemaArtifactContextJsonLdSpecification());

    rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES,
      renderParentSchemaArtifactPropertiesJsonSchemaSpecification(elementSchemaArtifact));

    rendering.put(ModelNodeNames.JSON_SCHEMA_REQUIRED, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_CONTEXT);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_ID);

    for (String childName : elementSchemaArtifact.getChildNames())
      rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(childName);

    if (elementSchemaArtifact.hasAttributeValueField())
      rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES,
        renderAdditionalPropertiesForAttributeValueFieldJsonSchemaSpecification());
    else
      rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES, false);

    rendering.put(ModelNodeNames.UI, mapper.valueToTree(elementSchemaArtifact.getElementUI()));

    // TODO isMultiple!!!

    return rendering;
  }

  /**
   * Generate a specification for a field schema artifact
   * <p></p>
   * An example artifact could look as follows:
   * <pre>
   * {
   *   "$schema": "http://json-schema.org/draft-04/schema#",
   *   "type": "object",
   *   "title": "Disease field schema", "description": "Disease field schema generated by the CEDAR Template Editor 2.6.19",
   *   "schema:name": "Disease", "schema:description": "Please enter a disease",
   *   "schema:schemaVersion": "1.6.0", "schema:identifier": "id5666",
   *   "pav:version": "0.0.1", "bibo:status": "bibo:draft",
   *   "pav:previousVersion": "https://repo.metadatacenter.org/templates/435454",
   *   "pav:derivedFrom": "https://repo.metadatacenter.org/templates/893443",
   *   "@type": "https://schema.metadatacenter.org/core/Template",
   *   "@id": "https://repo.metadatacenter.org/templates/127666",
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332",
   *   "@context": { ... },
   *   "properties": { ... },
   *   "required": [ "@id" ],
   *   "additionalProperties": false,
   *   "skos:prefLabel": "Condition", "skos:altLabel": [ "Problem", "Illness" ],
   *   "_valueConstraints": { ... },
   *   "_ui": { ... }
   *  }
   * </pre>
   */
  public ObjectNode renderFieldSchemaArtifact(FieldSchemaArtifact fieldSchemaArtifact)
  {
    ObjectNode rendering = renderSchemaArtifact(fieldSchemaArtifact);

    rendering.put(ModelNodeNames.JSON_LD_CONTEXT, renderSchemaArtifactContextPrefixesJsonLdSpecification());

    // Static fields have no JSON Schema fields (properties, required, additionalProperties), or
    // value constraints.
    if (!fieldSchemaArtifact.isStatic()) {

      if (fieldSchemaArtifact.hasIRIValue()) {
        rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES, renderIRIFieldArtifactPropertiesJsonSchemaSpecification());
        rendering.put(ModelNodeNames.JSON_SCHEMA_REQUIRED, mapper.createArrayNode());
        rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_ID);
      } else {
        rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES, renderLiteralFieldArtifactPropertiesJsonSchemaSpecification());
        // Non-IRI fields may have en empty object as a value so there are no required fields
      }

      rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES, false);

      if (fieldSchemaArtifact.getSkosPrefLabel().isPresent())
        rendering.put(ModelNodeNames.SKOS_PREFLABEL, fieldSchemaArtifact.getSkosPrefLabel().get().toString());

      if (!fieldSchemaArtifact.getSkosAlternateLabels().isEmpty()) {
        rendering.put(ModelNodeNames.SKOS_ALTLABEL, mapper.createArrayNode());
        for (String skosAlternateLabel : fieldSchemaArtifact.getSkosAlternateLabels())
          rendering.withArray(ModelNodeNames.SKOS_ALTLABEL).add(skosAlternateLabel.toString());
      }
      rendering.put(ModelNodeNames.VALUE_CONSTRAINTS, mapper.valueToTree(fieldSchemaArtifact.getValueConstraints()));
    }

    rendering.put(ModelNodeNames.UI, mapper.valueToTree(fieldSchemaArtifact.getFieldUI()));

    // TODO isMultiple!!!

    return rendering;
  }

  /**
   * Generate a base schema artifact rendering. In addition to core artifact fields (@type, @id, pav:createdOn,
   * pav:createdBy, pav:lastUpdatedOn, and oslc:modifiedBy), it will have JSON Schema fields (@schema, type,
   * title, description), Schema.org fields (schema:name, schema:description, schema:schemaVersion,
   * schema:identifier), version fields (pav:version, bibo:status, pav:previousVersion), and a derivation field
   * (pav:derivedFrom).
   * <p></p>
   * An example artifact could look as follows:
   * <pre>
   * {
   *   "$schema": "http://json-schema.org/draft-04/schema#",
   *   "type": "object",
   *   "title": "Study template schema", "description": "Bare template schema generated by the CEDAR Template Editor 2.6.19",
   *   "schema:name": "Study", "schema:description": "",
   *   "schema:schemaVersion": "1.6.0", "schema:identifier": "id4343",
   *   "pav:version": "0.0.1", "bibo:status": "bibo:draft",
   *   "pav:previousVersion": "https://repo.metadatacenter.org/templates/435454",
   *   "pav:derivedFrom": "https://repo.metadatacenter.org/templates/893443",
   *   "@type": "https://schema.metadatacenter.org/core/Template",
   *   "@id": "https://repo.metadatacenter.org/templates/127666",
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332"
   *  }
   * </pre>
   */
  private ObjectNode renderSchemaArtifact(SchemaArtifact schemaArtifact)
  {
    ObjectNode rendering = renderArtifact(schemaArtifact);

    rendering.put(ModelNodeNames.JSON_SCHEMA_SCHEMA, schemaArtifact.getJsonSchemaSchemaUri().toString());
    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, ModelNodeNames.JSON_SCHEMA_OBJECT);
    rendering.put(ModelNodeNames.JSON_SCHEMA_TITLE, schemaArtifact.getJsonSchemaTitle());
    rendering.put(ModelNodeNames.JSON_SCHEMA_DESCRIPTION, schemaArtifact.getJsonSchemaDescription());
    rendering.put(ModelNodeNames.SCHEMA_ORG_NAME, schemaArtifact.getName());
    rendering.put(ModelNodeNames.SCHEMA_ORG_DESCRIPTION, schemaArtifact.getDescription());

    if (schemaArtifact.getVersion().isPresent())
    rendering.put(ModelNodeNames.SCHEMA_ORG_SCHEMA_VERSION, schemaArtifact.getVersion().get().toString());

    if (schemaArtifact.getIdentifier().isPresent())
      rendering.put(ModelNodeNames.SCHEMA_ORG_IDENTIFIER, schemaArtifact.getIdentifier().get());

    if (schemaArtifact.getVersion().isPresent())
      rendering.put(ModelNodeNames.PAV_VERSION, schemaArtifact.getVersion().get().toString());

    if (schemaArtifact.getStatus().isPresent())
      rendering.put(ModelNodeNames.BIBO_STATUS, schemaArtifact.getStatus().get().toString());

    if (schemaArtifact.getPreviousVersion().isPresent())
      rendering.put(ModelNodeNames.PAV_PREVIOUS_VERSION,
        schemaArtifact.getPreviousVersion().get().toString());

    if (schemaArtifact.getDerivedFrom().isPresent())
      rendering.put(ModelNodeNames.PAV_DERIVED_FROM, schemaArtifact.getDerivedFrom().get().toString());

    return rendering;
  }

  /**
   * Generate an artifact rendering with core fields, which are @type, @id, pav:createdOn, pav:createdBy,
   * pav:lastUpdatedOn, and oslc:modifiedBy
   * <p></p>
   * An example artifact could look as follows:
   * <pre>
   * {
   *   "@type": "https://schema.metadatacenter.org/core/Template",
   *   "@id": "https://repo.metadatacenter.org/templates/6d21a997-b884-4779-966a-aa71632f3232",
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332"
   *  }
   * </pre>
   */
  private ObjectNode renderArtifact(Artifact artifact)
  {
    ObjectNode rendering = renderMonitoredArtifact(artifact);

    if (artifact.getJsonLdTypes().size() == 1) {
      rendering.put(ModelNodeNames.JSON_LD_TYPE, artifact.getJsonLdTypes().get(0).toString());
    } else if (artifact.getJsonLdTypes().size() > 1) {
      rendering.put(ModelNodeNames.JSON_LD_TYPE, mapper.createArrayNode());
      for (URI jsonLdType : artifact.getJsonLdTypes())
        rendering.withArray(ModelNodeNames.JSON_LD_TYPE).add(jsonLdType.toString());
    }

    if (artifact.getJsonLdId().isPresent())
      rendering.put(ModelNodeNames.JSON_LD_ID, artifact.getJsonLdId().get().toString());

    return rendering;
  }

  /**
   * Generate a monitored artifact rendering, which will have fields pav:createdOn, pav:createdBy, pav:lastUpdatedOn,
   * and oslc:modifiedBy
   * <p></p>
   * An example could look as follows:
   * <pre>
   * {
   *   "pav:createdOn": "2023-07-28T11:10:41-07:00", "pav:createdBy": "https://metadatacenter.org/users/656433",
   *   "pav:lastUpdatedOn": "2023-07-28T11:10:41-07:00", "oslc:modifiedBy": "https://metadatacenter.org/users/524332"
   *  }
   * </pre>
   */
  private ObjectNode renderMonitoredArtifact(MonitoredArtifact monitoredArtifact)
  {
    ObjectNode rendering = mapper.createObjectNode();

    if (monitoredArtifact.getCreatedBy().isPresent())
      rendering.put(ModelNodeNames.PAV_CREATED_BY, monitoredArtifact.getCreatedBy().get().toString());

    if (monitoredArtifact.getModifiedBy().isPresent())
      rendering.put(ModelNodeNames.OSLC_MODIFIED_BY, monitoredArtifact.getModifiedBy().get().toString());

    if (monitoredArtifact.getCreatedOn().isPresent())
      rendering.put(ModelNodeNames.PAV_CREATED_ON, monitoredArtifact.getCreatedOn().get().toString());

    if (monitoredArtifact.getLastUpdatedOn().isPresent())
      rendering.put(ModelNodeNames.PAV_LAST_UPDATED_ON, monitoredArtifact.getLastUpdatedOn().get().toString());

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for an additionalProperties field for a template or element containing
   * an attribute-value field
   * <p>
   * The specification is defined as follows:
   * <pre>
   * {
   *   "type": "object",
   *   "properties": {
   *     "@value": { "type": [ "string", "null" ] },
   *     "@type": { "type": "string", "format": "uri" }
   *   },
   *   "required": [ "@value" ],
   *   "additionalProperties": false
   * }
   * </pre>
   * The additional properties are of type object and contain two main properties:
   * - "@value": A string or null value.
   * - "@type": A string representing a URI.
   * <p>
   * The "@value" property is required, while the "@type" property is optional.
   * The "@value" property can hold a string value or be null, while the "@type" property must be a string in URI format.
   * <p>
   * Note that no other additional properties are allowed due to "additionalProperties" being set to false.
   */
  private ObjectNode renderAdditionalPropertiesForAttributeValueFieldJsonSchemaSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, ModelNodeNames.JSON_SCHEMA_OBJECT);
    rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES, mapper.createObjectNode());
    rendering.withObject("/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES).put(ModelNodeNames.JSON_LD_VALUE, renderStringOrNullJsonSchemaSpecification());
    rendering.withObject("/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES).put(ModelNodeNames.JSON_LD_TYPE, renderURIValueJsonSchemaSpecification());
    rendering.withObject("/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES).put(ModelNodeNames.JSON_SCHEMA_REQUIRED, mapper.createArrayNode());
    rendering.withObject("/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES).withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.JSON_LD_VALUE);
    rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES, false);

    return rendering;
  }

  /**
   * Render a JSON Schema properties specification in a parent schema artifact. This specification defines
   * the JSON-LD @context field in a parent artifact. In addition to standard prefixes (e.g., rdfs, xsd) and
   * fields (schema:name, pav:createdOn) the @context also contains property IRI mappings for every child field.
   * <p></p>
   * Defined as follows:
   * <pre>
   *   {
   *     "@context": {
   *       "type": "object",
   *       "properties": {
   *         "rdfs": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2000/01/rdf-schema#"] },
   *         "xsd": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2001/XMLSchema#"] },
   *         "pav": { "type": "string", "format": "uri", "enum": ["http://purl.org/pav/"] },
   *         "schema": { "type": "string", "format": "uri", "enum": ["http://schema.org/"] },
   *         "oslc": { "type": "string", "format": "uri", "enum": ["http://open-services.net/ns/core#"] },
   *         "skos": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2004/02/skos/core#"] },
   *         "rdfs:label": { "type": "object", "properties": { "@type": { "type": "string", "enum": ["xsd:string"] }}},
   *         "schema:isBasedOn": { "type": "object", "properties": {"@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "schema:name": { "type": "object", "properties": {"@type": { "type": "string",  "enum": ["xsd:string"] }}},
   *         "schema:description": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:string"] }}},
   *         "pav:derivedFrom": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "pav:createdOn": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:dateTime"] }}},
   *         "pav:createdBy": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "pav:lastUpdatedOn": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:dateTime"] }}},
   *         "oslc:modifiedBy": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }} },
   *         "skos:notation": { "type": "object", "properties": { "@type": { "type": "string", "enum": ["xsd:string"] }}},
   *         "<Child Name 1>": { "enum": [ "<CHILD_PROPERTY_URI_1>"] },
   *         ...
   *         "<Child Name n>": { "enum": [ "<CHILD_PROPERTY_URI_n>"] }
   *       },
   *       "required": [ "xsd", "pav", "schema", "oslc", "schema:isBasedOn", "schema:name", "schema:description",
   *                     "pav:createdOn", "pav:createdBy", "pav:lastUpdatedOn", "oslc:modifiedBy",
   *                     "<Child Name 1>", ... "<Child Name n>" ],
   *       "additionalProperties": false
   *     }
   * </pre>
   * A conforming instance should look as follows:
   * <pre>
   * {
   *   "@context": {
   *     "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
   *     "pav": "http://purl.org/pav/",
   *     "xsd": "http://www.w3.org/2001/XMLSchema#",
   *     "schema": "https://schema.org/",
   *     "oslc": "http://open-services.net/ns/core#",
   *     "skos": "http://www.w3.org/2004/02/skos/core#",
   *     "rdfs:label": { "@type": "xsd:string" },
   *     "schema:isBasedOn": { "@type": "@id" },
   *     "schema:name": { "@type": "xsd:string" },
   *     "schema:description": { "@type": "xsd:string" },
   *     "pav:derivedFrom": { "@type": "@id" },
   *     "pav:createdOn": {  "@type": "xsd:dateTime" },
   *     "pav:createdBy": { "@type": "@id" },
   *     "oslc:modifiedBy": { "@type": "@id" },
   *     "skos:notation": { "@type": "xsd:string" },
   *     "Child Name 1": "https://myschema.org/property/p1"
   *     ...
   *     "Child Name n": "https://myschema.org/property/pn"
   *   }
   * }
   * </pre>
   */
  private ObjectNode renderParentSchemaArtifactPropertiesJsonSchemaSpecification(ParentSchemaArtifact parentSchemaArtifact)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_CONTEXT,
      renderParentSchemaArtifactContextPropertiesJsonSchemaSpecification(parentSchemaArtifact));

    // TODO Put this set of core required fields in ModelNodeNames
    rendering.put(ModelNodeNames.JSON_SCHEMA_REQUIRED, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.XSD);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.OSLC);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA_ORG_NAME);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.SCHEMA_ORG_DESCRIPTION);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_CREATED_ON);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_CREATED_BY);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.PAV_LAST_UPDATED_ON);
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(ModelNodeNames.OSLC_MODIFIED_BY);

    // TODO Check that all children have an IRI mapping
    for (String childName : parentSchemaArtifact.getChildPropertyURIs().keySet())
      rendering.withArray(ModelNodeNames.JSON_SCHEMA_REQUIRED).add(childName);

    rendering.put(ModelNodeNames.JSON_SCHEMA_ADDITIONAL_PROPERTIES, false);

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for a @context properties specification in a parent artifact.
   * <p></p>
   * Defined as follows:
   * <pre>
   *   {
   *         "rdfs": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2000/01/rdf-schema#"] },
   *         "xsd": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2001/XMLSchema#"] },
   *         "pav": { "type": "string", "format": "uri", "enum": ["http://purl.org/pav/"] },
   *         "schema": { "type": "string", "format": "uri", "enum": ["http://schema.org/"] },
   *         "oslc": { "type": "string", "format": "uri", "enum": ["http://open-services.net/ns/core#"] },
   *         "skos": { "type": "string", "format": "uri", "enum": ["http://www.w3.org/2004/02/skos/core#"] },
   *         "rdfs:label": { "type": "object", "properties": { "@type": { "type": "string", "enum": ["xsd:string"] }}},
   *         "schema:isBasedOn": { "type": "object", "properties": {"@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "schema:name": { "type": "object", "properties": {"@type": { "type": "string",  "enum": ["xsd:string"] }}},
   *         "schema:description": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:string"] }}},
   *         "pav:derivedFrom": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "pav:createdOn": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:dateTime"] }}},
   *         "pav:createdBy": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }}},
   *         "pav:lastUpdatedOn": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["xsd:dateTime"] }}},
   *         "oslc:modifiedBy": { "type": "object", "properties": { "@type": {  "type": "string",  "enum": ["@id"] }} },
   *         "skos:notation": { "type": "object", "properties": { "@type": { "type": "string", "enum": ["xsd:string"] }}},
   *         "<Child Name 1>": { "enum": [ "<PROPERTY_URI_1>"] },
   *         ...
   *         "<Child Name n>": { "enum": [ "<PROPERTY_URI_n>"] }
   *     }
   * </pre>
   * A conforming instance should look as follows:
   * <pre>
   *   {
   *     "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
   *     "xsd": "http://www.w3.org/2001/XMLSchema#",
   *     "pav": "http://purl.org/pav/",
   *     "schema": "https://schema.org/",
   *     "oslc": "http://open-services.net/ns/core#",
   *     "skos": "http://www.w3.org/2004/02/skos/core#",
   *     "rdfs:label": { "@type": "xsd:string" },
   *     "schema:isBasedOn": { "@type": "@id" },
   *     "schema:name": { "@type": "xsd:string" },
   *     "schema:description": { "@type": "xsd:string" },
   *     "pav:derivedFrom": { "@type": "@id" },
   *     "pav:createdOn": {  "@type": "xsd:dateTime" },
   *     "pav:createdBy": { "@type": "@id" },
   *     "oslc:modifiedBy": { "@type": "@id" },
   *     "skos:notation": { "@type": "xsd:string" },
   *     "Child Name 1": "https://myschema.org/property/p1"
   *     ...
   *     "Child Name n": "https://myschema.org/property/pn"
   *   }
   * </pre>
   */
  private ObjectNode renderParentSchemaArtifactContextPropertiesJsonSchemaSpecification(ParentSchemaArtifact parentSchemaArtifact)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.RDFS, renderJsonSchemaUriEnumSpecification("http://www.w3.org/2000/01/rdf-schema#"));
    rendering.put(ModelNodeNames.XSD, renderJsonSchemaUriEnumSpecification("http://www.w3.org/2001/XMLSchema#"));
    rendering.put(ModelNodeNames.PAV, renderJsonSchemaUriEnumSpecification("http://purl.org/pav/"));
    rendering.put(ModelNodeNames.SCHEMA, renderJsonSchemaUriEnumSpecification("http://schema.org/"));
    rendering.put(ModelNodeNames.OSLC, renderJsonSchemaUriEnumSpecification("http://open-services.net/ns/core#"));
    rendering.put(ModelNodeNames.SKOS, renderJsonSchemaUriEnumSpecification("http://www.w3.org/2004/02/skos/core#"));

    rendering.put(ModelNodeNames.RDFS_LABEL, renderJsonSchemaJsonLdDatatypeSpecification("xsd:string"));
    rendering.put(ModelNodeNames.SCHEMA_IS_BASED_ON, renderJsonSchemaJsonLdDatatypeSpecification(ModelNodeNames.JSON_LD_ID));
    rendering.put(ModelNodeNames.SCHEMA_ORG_NAME, renderJsonSchemaJsonLdDatatypeSpecification("xsd:string"));
    rendering.put(ModelNodeNames.SCHEMA_ORG_DESCRIPTION, renderJsonSchemaJsonLdDatatypeSpecification("xsd:string"));
    rendering.put(ModelNodeNames.PAV_DERIVED_FROM, renderJsonSchemaJsonLdDatatypeSpecification(ModelNodeNames.JSON_LD_ID));
    rendering.put(ModelNodeNames.PAV_CREATED_ON, renderJsonSchemaJsonLdDatatypeSpecification("xsd:dateTime"));
    rendering.put(ModelNodeNames.PAV_CREATED_BY, renderJsonSchemaJsonLdDatatypeSpecification(ModelNodeNames.JSON_LD_ID));
    rendering.put(ModelNodeNames.PAV_LAST_UPDATED_ON, renderJsonSchemaJsonLdDatatypeSpecification("xsd:dateTime"));
    rendering.put(ModelNodeNames.OSLC_MODIFIED_BY, renderJsonSchemaJsonLdDatatypeSpecification(ModelNodeNames.JSON_LD_ID));
    rendering.put(ModelNodeNames.SKOS_NOTATION, renderJsonSchemaJsonLdDatatypeSpecification("xsd:string"));

    for (Map.Entry<String, URI> entry : parentSchemaArtifact.getChildPropertyURIs().entrySet()) {
      String childName = entry.getKey();
      URI propertyURI = entry.getValue();
      rendering.put(childName, propertyURI.toString());
    }
    
    return rendering;
  }

  /**
   * Generate a JSON Schema specification for a URI-formatted string value with a specific value.
   * <p></p>
   * Defined as follows:
   * <pre>
   * { "type": "string", "format": "uri", "enum": ["<IRI>"] }
   * </pre>
   * A conforming value could look as follows:
   * <pre>
   *   "http://purl.org/pav/"
   * </pre>
   */
  private ObjectNode renderJsonSchemaUriEnumSpecification(String uri)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, "string");
    rendering.put(ModelNodeNames.JSON_SCHEMA_FORMAT, "uri");
    rendering.put(ModelNodeNames.JSON_SCHEMA_ENUM, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_ENUM).add(uri);

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for a JSON-LD @type datatype specification
   * <p></p>
   * Defined as follows:
   * <pre>
   * { "type": "object", "properties": { "@type": { "type": "string", "enum": ["<DATATYPE>"] }}},
   * </pre>
   * A conforming value could look as follows:
   * <pre>
   *   { "@type": "xsd:string" }
   * </pre>
   */
  private ObjectNode renderJsonSchemaJsonLdDatatypeSpecification(String datatype)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, ModelNodeNames.JSON_SCHEMA_OBJECT);
    rendering.put(ModelNodeNames.JSON_SCHEMA_PROPERTIES, mapper.createObjectNode());
    rendering.withObject("/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES).put(ModelNodeNames.JSON_LD_TYPE, mapper.createObjectNode());
    rendering.withObject("/" + "/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES)
      .withObject("/" + "/" + ModelNodeNames.JSON_LD_TYPE).put(ModelNodeNames.JSON_SCHEMA_TYPE, "string");
    rendering.withObject("/" + "/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES)
      .withObject("/" + "/" + ModelNodeNames.JSON_LD_TYPE).put(ModelNodeNames.JSON_SCHEMA_ENUM, mapper.createArrayNode());
    rendering.withObject("/" + "/" + ModelNodeNames.JSON_SCHEMA_PROPERTIES)
      .withObject("/" + "/" + ModelNodeNames.JSON_LD_TYPE).withArray(ModelNodeNames.JSON_SCHEMA_ENUM).add(datatype);

    return rendering;
  }

  /**
   * Generate a JSON-LD @context for parent schema artifacts (i.e., templates and elements)
   * <p>
   * Defined as follows:
   * <pre>
   *   "@context": {
   *     "xsd": "http://www.w3.org/2001/XMLSchema#",
   *     "pav": "http://purl.org/pav/",
   *     "bibo": "http://purl.org/ontology/bibo/",
   *     "oslc": "http://open-services.net/ns/core#",
   *     "schema": "http://schema.org/",
   *     "skos": "http://www.w3.org/2004/02/skos/core#",
   *     "schema:name": { "@type": "xsd:string" },
   *     "schema:description": { "@type": "xsd:string" },
   *     "pav:createdOn": { "@type": "xsd:dateTime" },
   *     "pav:createdBy": { "@type": "@id" },
   *     "pav:lastUpdatedOn": { "@type": "xsd:dateTime" },
   *     "oslc:modifiedBy": { "@type": "@id" }
   *   }
   * </pre>
   */
  private ObjectNode renderParentSchemaArtifactContextJsonLdSpecification()
  {
    ObjectNode rendering = renderSchemaArtifactContextPrefixesJsonLdSpecification();

    rendering.put(ModelNodeNames.SCHEMA_ORG_NAME, renderXSDStringJsonLdSpecification());
    rendering.put(ModelNodeNames.SCHEMA_ORG_DESCRIPTION, renderXSDStringJsonLdSpecification());
    rendering.put(ModelNodeNames.PAV_CREATED_ON, renderXSDDateTimeJsonLdSpecification());
    rendering.put(ModelNodeNames.PAV_CREATED_BY, renderIRIJsonLdSpecification());
    rendering.put(ModelNodeNames.PAV_LAST_UPDATED_ON, renderXSDDateTimeJsonLdSpecification());
    rendering.put(ModelNodeNames.OSLC_MODIFIED_BY, renderIRIJsonLdSpecification());

    return rendering;
  }

  /**
   * Generate JSON-LD @context prefix specification for schema artifacts
   * <p></p>
   * Defined as follows:
   * <pre>
   *   "@context": {
   *     "xsd": "http://www.w3.org/2001/XMLSchema#",
   *     "pav": "http://purl.org/pav/",
   *     "bibo": "http://purl.org/ontology/bibo/",
   *     "oslc": "http://open-services.net/ns/core#",
   *     "schema": "http://schema.org/",
   *     "skos": "http://www.w3.org/2004/02/skos/core#"
   *   }
   * </pre>
   */
  private ObjectNode renderSchemaArtifactContextPrefixesJsonLdSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    // TODO Put these IRIs in the ModelNodeNames class
    rendering.put(ModelNodeNames.XSD, "http://www.w3.org/2001/XMLSchema#");
    rendering.put(ModelNodeNames.PAV, "http://purl.org/pav/");
    rendering.put(ModelNodeNames.BIBO, "http://purl.org/ontology/bibo/");
    rendering.put(ModelNodeNames.OSLC, "http://open-services.net/ns/core#");
    rendering.put(ModelNodeNames.SCHEMA, "http://schema.org/");
    rendering.put(ModelNodeNames.SKOS, "http://www.w3.org/2004/02/skos/core#");

    return rendering;
  }


  /**
   * Generate a JSON Schema properties specification for a literal-valued field
   * <p></p>
   * Defined as follows:
   * <pre>
   * {
   *   "@type": {
   *     "oneOf": [
   *       { "type": "string", "format": "uri" },
   *       { "type": "array", "minItems": 1, "items": { "type": "string", "format": "uri" },  "uniqueItems": true }
   *     ]
   *   },
   *   "rdfs:label": {  "type": [ "string", "null" ] },
   *   "@value": {  "type": [ "string", "null" ] }
   * }
   * </pre>
   * A conforming value could look like:
   * <pre>
   * {
   *   "@type": "http://www.w3.org/2001/XMLSchema#string",
   *   "@value": "Bob"
   * }
   * </pre>
   */
  private ObjectNode renderLiteralFieldArtifactPropertiesJsonSchemaSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_TYPE, renderURIOrURIArrayJsonSchemaSpecification(1, true));
    rendering.put(ModelNodeNames.RDFS_LABEL, renderStringOrNullJsonSchemaSpecification());
    rendering.put(ModelNodeNames.JSON_LD_VALUE, renderStringOrNullJsonSchemaSpecification());

    return rendering;
  }


  /**
   * Generate a JSON Schema properties specification for a IRI-valued field
   * <p>
   * Defined as follows:
   * <pre>
   * {
   *   "@type": {
   *     "oneOf": [
   *       { "type": "string", "format": "uri" },
   *       { "type": "array", "minItems": 1, "items": { "type": "string", "format": "uri" },  "uniqueItems": true }
   *     ]
   *   },
   *   "rdfs:label": {  "type": [ "string", "null" ] },
   *   "@id": { "type": "string", "format": "uri" }
   * }
   * </pre>
   * A conforming value could look like:
   * <pre>
   * {
   *   "rsfs:label": "Melanoma",
   *   "@id": "http://purl.bioontology.org/ontology/LNC/LA14279-6"
   * }
   * </pre>
   */
  private ObjectNode renderIRIFieldArtifactPropertiesJsonSchemaSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_TYPE, renderURIOrURIArrayJsonSchemaSpecification(1, true));
    rendering.put(ModelNodeNames.RDFS_LABEL, renderStringOrNullJsonSchemaSpecification());
    rendering.put(ModelNodeNames.JSON_LD_ID, renderURIValueJsonSchemaSpecification());

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for a string or null value
   * <p>
   * Defined as follows:
   * <pre>
   *   { "type": [ "string", "null" ] }
   * </pre>
   */
  private ObjectNode renderStringOrNullJsonSchemaSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_TYPE).add("string");
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_TYPE).add("null");

    return rendering;
  }

  /**
   * Generate a JSON-LD @type specification for an xsd:string
   * <p>
   * Defined as follows:
   * <pre>
   *   { "@type": "xsd:string" }
   * </pre>
   */
  private ObjectNode renderXSDStringJsonLdSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_TYPE, "xsd:string");

    return rendering;
  }

  /**
   * Generate a JSON-LD @type specification for an xsd:dateTime
   * <p>
   * Defined as follows:
   * <pre>
   *   { "@type": "xsd:dateTime" }
   * </pre>
   */
  private ObjectNode renderXSDDateTimeJsonLdSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_TYPE, "xsd:dateTime");

    return rendering;
  }

  /**
   * Generate a JSON-LD @type specification for an IRI
   * <p>
   * Defined as follows:
   * <pre>
   *   { "@type": "@id" }
   * </pre>
   */
  private ObjectNode renderIRIJsonLdSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_LD_TYPE, ModelNodeNames.JSON_LD_ID);

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for a URI-formatted string
   * <p>
   * Defined as follows:
   * <pre>
   *   { "type": "string", "format": "uri" }
   * </pre>
   */
  private ObjectNode renderURIValueJsonSchemaSpecification()
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, "string");
    rendering.put(ModelNodeNames.JSON_SCHEMA_FORMAT, "uri");

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for URI-formatted string or URI-formatted string array
   * <p>
   * Defined as follows:
   * <pre>
   * {
   *   "oneOf": [
   *     { "type": "string", "format": "uri" },
   *     { "type": "array", "minItems": 1, "items": { "type": "string", "format": "uri" }, "uniqueItems": true }
   *   ]
   * }
   * </pre>
   */
  private ObjectNode renderURIOrURIArrayJsonSchemaSpecification(int minItems, boolean uniqueItems)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_ONE_OF, mapper.createArrayNode());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_ONE_OF).add(renderURIValueJsonSchemaSpecification());
    rendering.withArray(ModelNodeNames.JSON_SCHEMA_ONE_OF).add(renderURIArrayJsonSchemaSpecification(1, true));

    return rendering;
  }

  /**
   * Generate a JSON Schema specification for URI-formatted string array
   * <p>
   * Defined as follows:
   * <pre>
   * { "type": "array", "minItems": 1, "items": { "type": "string", "format": "uri" }, "uniqueItems": true }
   * </pre>
   */
  private ObjectNode renderURIArrayJsonSchemaSpecification(int minItems, boolean uniqueItems)
  {
    ObjectNode rendering = mapper.createObjectNode();

    rendering.put(ModelNodeNames.JSON_SCHEMA_TYPE, ModelNodeNames.JSON_SCHEMA_ARRAY);
    rendering.put(ModelNodeNames.JSON_SCHEMA_MIN_ITEMS, minItems);
    rendering.put(ModelNodeNames.JSON_SCHEMA_ITEMS, mapper.createObjectNode());
    rendering.withObject("/" + "/" + ModelNodeNames.JSON_SCHEMA_ITEMS).put(ModelNodeNames.JSON_SCHEMA_TYPE, "string");
    rendering.withObject("/" + "/" + ModelNodeNames.JSON_SCHEMA_ITEMS).put(ModelNodeNames.JSON_SCHEMA_FORMAT, "uri");
    rendering.put(ModelNodeNames.JSON_SCHEMA_UNIQUE_ITEMS, uniqueItems);

    return rendering;
  }
}
